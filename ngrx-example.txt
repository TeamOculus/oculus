-people.reducer.ts 
// reducers are required to be pure functions
// always return a new version of state
export const people = (state=[], action) => {
    switch(action.type){
        case "ADD_PERSON": 
            return [...state, action.payload]
        case "REMOVE_PERSON":
            return state;
        case "ADD_GUESTS":
            return state;
        case "TOGGLE_ATTENDING":
            return state;
        default: 
            return state;
    }
}
-----------------------------------------------------------------------------
-app.module.ts
import {Store, provideStore} from '@ngrx/store';

bootstrap(App, [
    provideStore({people, filter})
])
-----------------------------------------------------------------------
-some component
import {Store, provideStore} from '@ngrx/store';
import {people} from <'people reducer file location'>
import {filter} from <'people reducer file location'>

template: <person-list [people]="people | async"></person-list>

pipes: [AsyncPipe]

export class Component {
    public people;
    private id = 0;

    constructor(
        private _store: Store<any>
    ){
        // accessing a part of the store
        // select is the same as map(state => state['people']).distinctUntilChanged()
        
       // _store.select('people')
        //    .subscribe(people => {
        //        this.people = people;
        //   })

        this.people = Observable.combineLatest(
            _store.select('people'),
            _store.select('filter'),
            (people, filter) = > {
                return people.filter(filter);
            }
        ) 
    }

    addPerson(name){
        this._store.dispatch({type: "ADD_PERSON", payload: {
            id: ++this.id,
            name, 
            guests: 0,
            attending: false
        }})
    }
}

